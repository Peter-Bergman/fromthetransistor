1.	We need to make sure that when we branch and we reset the program counter, we also reset the instruction_waiting <= 0; and instruction_ready <= 0;

DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE 


2.	We need to make sure that we are not forgetting any assignments for any of the phases. We have added several interphase registers that probably have not all been included in the logic since the last time
	the assignments were updated thoroughly.

	decode_execute wires need to be declared.

	

3.	We need to make sure that the commutativity and exclusivity of the hazard checks does not matter. If the order of the hazard checks does matter, then we need to determine the correct order and reflect that order in the code.
	
	All potential hazards with memory are dependent on the execute_memory_access registers' values and only when we are writing to memory in the memory access phase.
	All potential branch hazards also are dependent on the execute_memory_access registers' values and only when we have a branch or jump instruction.
	Since no branch or jump instruction writes to memory during the memory access phase, it is impossible for us to have a branch hazard and a memory RAW hazard in a single clock cycle.
	Therefore, it does not matter whether branch hazard checking logic comes before or after memory access hazard checking logic.
	
	When a branch or jump instruction is in the execute_memory_access registers, and the branch_signal is high, the following changes are made:
		- The execute_memory_access_pc_reg is set to 0
		- The decode_execute_pc_reg is set to 0
		- The fetch_decode_pc_reg is set to 0
		- The pc register is set to execute_memory_access_branch_result_reg
		- The waiting register is set to low (SNTBI) DONE DONE
	When register RAW hazards are detected, the following changes are made:
		- the instruction stored in the fetch_decode registers does not pass onto the decode_execute_registers. In other words, can_decode is False (SNTBI). Therefore, can_fetch is False.
		- 
	If there is a register RAW hazard and a branch hazard, and the RAW hazard is handled first, any change that would be made by the handling of RAW hazard is nullified.
	This is provable because all of the inter-phase registers are nullified when the branch or jump sets all of the program counters before memory_access_write_back registers to 0.
	If there is a register RAW hazard and a branch hazard, and the branch hazard is handled first, the register RAW hazard logic will keep the fetch_decode_pc_reg the same, and the pc reg will remain the same also.
	This is a problem because the instruction in the fetch_decode registers should not be executed.
	The instruction in the fetch_decode registers should not be executed because the branch/jump result should be the next instruction to execute after the branch/jump instruction.

DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE 


4.	We need to make sure that we actually need the instruction_ready signal.
	
	Suppose that we have a single bit instruction_ready_reg register that drives an instruction_ready signal.
	We know for sure that the waiting register will need to be set to low when we branch or jump whether there is a ready signal or not.
	Suppose that we set the instruction_ready_reg to low when a branch/jump instruction resets the program counter.
	We would have the following logic: `if ( !instruction_ready_reg ) begin instruction_ready_reg <= 1'b1; end`
	This would take an extra (UNDETERMINED) clock cycles. I think for now, this is acceptable, since we are just making a minimalist implementation with the only cool thing being pipelining.
	I have decided to use an instruction_ready output register.

DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE 


5.	We need to make sure that if can_fetch is False, and can_decode is True, then fetch_decode_pc_reg <= 32'b0; (SNTBI)

DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE 

6.	We need to add the logic for the instruction_ready output register.

	The instruction_ready register needs to be set to 0 (low) when and only when the pc register is set.
	Side note: the instruction_waiting register will also be set to low any time the pc register is set. This is not the only case when instruction_waiting is set to low, though.
	
	If instruction_ready is low, set it to high.
	There are four (4) cases where we would set the instruction_ready register to low.
	These four (4) cases are all of the times that we change the value of the program counter (pc) register.
	These are the four (4) cases when we would change the program counter (pc):
		- can_fetch is high, and we increment the program counter. We increment the program counter by the following code: `pc <= next_pc;`
		- execute_memory_access_branch_signal_reg is high, and we set the program counter as follows: `pc <= execute_memory_access_branch_result;`
		- main_memory_read_after_write_hazard1 is high, and we set the program counter as follows: `pc <= decode_execute_pc_reg - 4;`
		- main_memory_read_after_write_hazard2 is high, and we set the program counter as follows: `pc <= fetch_decode_pc_reg - 4;`

DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE 

	

7.	We need to determine if it is necessary to use a memory_ready output register or if we could rely on the execute_memory_access read and write registers instead. 
	
	Intuitively, I think we can just use the execute_memory_access read and write registers to indicate if we are ready to read from or write to memory.
	
	We do not need a ready signal.

	We need to make sure that any time the execute_memory_access_pc_reg is set to 0, we also set both execute_memory_access_read_reg and execute_memory_access_write_reg to 0 as well.
	Here is the code we would use to do that:
	"""
		execute_memory_access_read_reg <= 1'b0;
		execute_memory_access_write_reg <= 2'b0;
	"""
	That code is subject to change if we change the size of the read register. The read register might be two bits wide in the future like the write register.
	(IN) We will not need to change the size of the read register. There are no hazards related to the memory access read, so changing the amount of data to pull would not make a difference. We also have the reg_write_reg
	(IN c) register to indicate how much of the data read from memory should be written back to the register file. Writing back to the register file is the only thing that can possibly be done with data read from memory.
	There are two changes we need to make in order to accomplish this:
		- Search through the code. See where execute_memory_access_pc_reg is set to 0. Simply add the above code.
		- Under the if ( can_execute ) block, add an embedded if block like with the above code in it and the following condition: `if ( !decode_execute_pc_reg )`
	I believe that there are no other cases where the execute_memory_access_pc_reg could be set to 0, but if there are other times, insert into the code the same embedded conditional and block as the second case listed.

DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE 

8.	We need to double check that the hazards signal assignments are correct.
	
	I think that the register RAW assignment is off because of the order of boolean order of operations.

	Using the select_register1 and select_register2 signals for the register_read_after_write_hazard signal assignment looks clean, but I don't think it is right.
	I could just create two wires that are driven directly by the instruction in the fetch_decode_instruction_reg register.

DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE 

9.	The memory RAW hazards have faulty arithmetic. We should not be adding the execute_memory_access_write_reg to the store_val_reg. Instead, we need to create a wire that has a value mapped from the write_reg.
	The mapping should be like so:
		0 -> 0,
		1 -> 0,
		2 -> 1,
		3 -> 3

	This is the code we should use for that wire assignment:
	"""
		assign mapped_wire = execute_memory_access_write_reg[1] ? ( execute_memory_access_write_reg[0] ? 2'd3 : 2'd1 ) : 2'd0;
	"""

DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE 

10.	I need to add logic for main_memory_read_after_write_hazard3 signal.
	
	When that signal is high, the following needs to be done:
		- Set the instruction_ready output register to low like so, `instruction_ready <= 1'b0;`
		- Set the instruction_waiting signal to low like so, `instruction_waiting <= 1'b0;`
	
	It should be noted that this contradicts something said in an earlier note.
	The instruction_ready register is not set to 0 when and only when the pc register is set to a new value.
	The instruction_ready register is set to 0 any time the pc register is changed, but it is now no longer only set to 0 when the pc register is set to a new value.

DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE 

11.	I need to find what I was trying to do with the decode_execute_branch_reg variable, and if it is not necessary, delete it.

	deleted it.

DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE 

12.	I need to make sure that all of the wires needed for the decoder are in place. I also need to make sure that the decoder has logic for every wire.

	Wires that do not have logic written up yet:
	 - reg_write
	 - write
	 - read
	(I think that's all)

DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE DONE 
	
13.	CSR instructions need to be implemented. The pipeline will not need many changes.
	
	Here are some things to do:
	 - Need to see if we should wait for all prior instructions to finish executing before accessing one of the CSRs.
	 - Need to add in logic to stop CSR register hazards.
	 - Need logic in the decoder to grab the unsigned immediate from CSR instructions .......................................
	 - Need to add module instance of CSR regsiter file in control_section.
	 - Need to add registers in pipeline for CSR instructions to operate.
		- csr immediate
		- csr writeback
		- selected csr register value (the value in the csr that was selected by the 12 bit uimmediate)

	 I think I am going to wait for all prior instructions to finish executing and writing back. The instruction retired CSR might be read to have unexpected values if we don't wait.

