----------------------------General ------------------------------

The representations of all types are unspecified except as stated in this subclause.

Except for bit-fields, objects are composed of contiguous sequences of one or more bytes, the number, order, and encoding of which are either explicitly specified or implementation-defined.

Values stored in unsigned bit-fields and objects of type unsigned char shall be represented using a pure binary notation.

Values stored instored in non-bit-field objects of any oher object type consist of n * CHAR_BIT bits, where n is the size of an object of that type, in bytes.
The value may be copied into an object of type unsigned char [n] (e.g. by memcpy); the resulting set of bytes is called the object representation of the value.

Values stored in bit-fields consist of m bits, where m is the size specified for the bit-field.
The object representation is the set of m bits the bit-field comprises in the addressable storage unit holding it.
Two values (other than NaNs) with the same object representation compare equal, but values that compare equal may have different object representations.

Certain object representations need not represent a value of the object type.
If the stored value of an object has such a representation and is read by an lvalue expression that does not have character type, the behavior is undefined.
If such a representation is produced by a side effect that modifies all or any part of the object by an lvalue expression that does not have character type, the behavior is undefined. 
Such a representation is called a trap representation.

When a value is stored in an object of structure or union type, including in a member object, the bytes of the object representation that correspond to any padding byes take unspecified values.
The value of a structure or union object is never a trap representation, even though tthe value of a member of the structure or union object may be a trap representation.

Where an operator is applied to a value that has more than one object representation, which object representation is used shall not affect the value of the result.
Where a value is stored in an object using a type that has more than one object representation for that value, it is unspecified which representation is used, but a trap representation shall not be generated.



------------------------ Integer Types ---------------------------

For unsigned integer types other than unsigned char, the bits of the object representaion shall be divided into two groups: value bits and padding bits (there need not be any of the latter).
The values of any padding bits are unspecified.

For signed integer types, the bits of the objectt representation shall be divided into hree groups: value bits, padding bits, and the sign bit. There need not be any padding bits; signed char shall not have any padding bits.
If the sign bit is one, the value shall be modified in one of the following ways:
 - the corresponding value with sign bit 0 is negated (sign and magnitude)
 - the sign bit has value of two's complement
 - the sign bit has value of one's complement

Which of these applies is implementation-defined, as is whether the value with sign bit 1 and all value bits zero (for the first two), or with sign bit and all value bits 1 (for ones' complement), is a trap representation or a normal value. In the case of sign and magnitude and ones' complement, if this representation is a normal value it is called negative zero.

If the implementation supports negative zeros, they shall be generated only by:
 - the &, |, ^, ~, <<, and >> operators with operands that produce such a value
 - the +, -, *, /, and % operators where one operand is a negative zero and the result is zero
 - compound assignment operators based on the above cases.

It is unspecified whether these cases actually generate a negative zero or a normal zero, and whether a negative zero becomes a normal zero when stored in an object.

If the implementation does not support negative zeros, the behavior of the &,, ^, ~, <<, and >> operators with operands that would produce such a value is undefined.

For any integer type, the object representation where all the bits are zero shall be a representation of the value zero in that type.

The precision of an integer type is the number of bits it uses to represent values, excluding any sign and padding bits. The width of an integer type is the same but including any sign bit.


