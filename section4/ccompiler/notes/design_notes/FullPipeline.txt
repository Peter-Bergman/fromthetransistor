I have moved over to this file for notes.
You know what, I think I am going to check in what I have for now.
I think there are already a lot of changes.
I just found out about git difftool and vimdiff.
That shit is awesome.
I like it.
The colors are dumb for now, but the tools are cool, and I am going to use them.
I can configure the colors to be more helpful some time, anyways.

I have a couple directions that I can go in now.
I can begin writing tests.
That does not align with my idea of creating a minimal pipeline.
I will not spend time writing tests yet.
I could create a manual instance of Show for Identifier in the AST.
I would get rid of the derivation that implements Show Identifier currently.
As I was doing some basic testing on declarators and init-declarators, I think I noticed something seemed off.
I did not dig into it, and I do not remember it in detail.
My concern was the ordering of alternatives that can be parsed.
I will just leave it at that for now.
I think I will hold off manually implementing Show Identifier for now.
That sounds like a potential slow-down.
I will fix correctness issues later, especially if it is just a matter of the order of alternatives.
I am half expecting that to be an issue, and I will be able to find it pretty quickly, I think.
Okay, then what do I have to implement next.
I think the next thing I have to implement is the initializer syntax tree.
I want to look over the iso document first and get an idea of which piece of syntax I need to implement next.
I just realized that I have not specified what I am trying to implement in my minimal pipeline.
I want to be able to simply define an external variable (one outside of a procedure) as an integer and initialize its value.
You know what, maybe it would be even simpler to not even initialize that value.
I am going to try that with gcc.
It works.
My program just had the code `int x;`
It compiled perfectly fine.
It was just an object file, but that's fine for now.
I am okay with that for now.
When the code gets to the assembler, I can inspect that code because the assembler is written in python.
I just ran `stack repl Compiler/Parser/TranslationUnit.hs`
Inside of the ghci interpreter that opened up, I tinkered with the translationUnit parser.
I ran `testParse translationUnit ["int", "x", ";"]`
I believe that parsed what it should have.
However, if I added a space in the mix, it failed.
Running `testParse translationUnit ["int", " ", "x", ";"]` returned what the following.

parse error at (line 1, column 5):
unexpected "x"
expecting declaration specifiers

I am surprised.
I will look into this.
I will grep for "declaration specifiers".
I got a match.
I am digging in now using parserTrace in the Text.Parsec.Combinator module.
I think it might be my charToStringTokenParser implementation.
I wonder if it is an issue with the handling of the whitespace.
The error message seems as if the whitespace was properly skipped, though.
Well, it definitely is an issue with the way that the whitespace is skipped.
The parse works without the space, but not with the space.
Yes, it's a spacing issue.
The charToStringTokenParser implementation does not have any code for handling whitespace.
I am going to either change or parameterize that.
I think I'll just parameterize it.
Well, I could also write a wrapper for charToStringTokenParser that would parse preceding whitespace.
I don't like whitespace.
The whole lparen thing makes it so much more complicated.
It turns out that I wrote code that skips horizontal whitespace already.
It is in the stringSatisfyT definition.
I extracted the code for skipping horizontal whitespace.
In order to comply with the C standard, I might need to make the code handle newlines, not just horizontal whitespace, but I will leave it for now.
I will change the identifier definition in Preprocessor.Identifier now.
I have to change module imports and exports for that to work.
Now the whole parse works.
I get the same parse result when I have the space in the input stream to be parsed and when I don't.
The code seems to be parsing the sample string properly.
I guess I am going to move onto the next phase.
I guess that would be semantic analysis.
I will have to read the constraints and semantics of each entity that I parsed.
I might make a typeclass for constraint checks and semantic analysis.
I am looking at the first constraint.
I think that ...

I don't know what I was thinking when I began my last sentence.
I am going to read the preceding content.
I was just reading the notes.
Now, I don't remember what the difference is between the stringSatisfyT ish functions and the charToStringTokenParser function.
I am going to look at that now.
Well, charToStringTokenParser, I believe, is kind of like a cleaner version of stringParserSatisfyT.
It does not exclusively transform parsers with the type Parser String.
The stringParserSatisfyT parser transformer will transform a (Parser String) to a (String -> Bool), and if the (String -> Bool) returns True, stringParserSatisfyT transforms the parsed string to type t.
Then, stringParserSatisfyT returns the result of that transformation of the parsed string to type t.
I am going to leave a TODO comment for getting rid of stringParserSatisfyT.
I could write some nice documentation for this stuff, but I wanna get my minimal pipeline done.

I am going to continue reading my notes from two paragraphs above.
Okay, I have to write code to audit the constraints.
I almost want to run audits while parsing.
I think there are a few constraints that I already enforce in the parsers.
I just looked at the second constraint listed in section 6.9.
The constraint has a 3 next to it.
That constraint requires a symbol table.
It requires state.
I feel slightly inclined to not use state, if I don't need to.
However, I think that if I wait until parsing is finished to do constraint checks, the parsing precedence might be messed up.
Some code might parse, but then fail constraint checks later in the pipeline.
This could conceivably happen when the parsed code could have been parsed in another way.
I am not certain that I will be able to stomp out this possibility by simply ordering/reordering the alternatives (parsers combined with the <|> operator).
That said, I think it will be easiest for now if I have constraint audits in a separate stage of the pipeline.
You know what, though, I could parameterize the method that performs constraint checks with a boolean that would determine whether or not to perform recursive constraint checks on the descendent nodes.
I have not written out my idea for the use of typeclasses here yet.
I think it could be good to use a typeclass that would have a method that checks all of the constraints for a given node in the AST.
I could name that method checkConstraints or something like that.
I think it would return a Bool.
It could also return a Maybe type.
I think it would be a Bool because I only need two values, pass or fail.
I could probably find some nice way to sugar it up, but for now I think having True represent pass and False represent fail is fine.
I guess I will implement the typeclass in the AbstractSyntaxTree module for now.
I am naming the type class Auditable for now.
I did it.
I think I did it correctly.
I believe this is the first typeclass I have ever defined.
I have implemented them before, but I think this is the first one I have defined.
It compiiled!
Okay, now I am going to try to implement this typeclass inside the AbstractSyntaxTree module.
You know what, I think there is going to be a lot of stuff in the next commit.
I want to just commit my progress.
This paragraph is not included in the commit I just made.
Anyways, I am moving on with a much cleaner working tree.
I just made some more abstractions to the Auditable typeclass.
There are now three methods: checkConstraints, checkConstraintsOfNode, and checkConstraintsOfDescendentNodes.
The checkConstraints method is defined using the others.
I changed the typeclass again.
It has three methods: checkConstraintsOfNodeAndDescendents, checkConstraintsOfNode, and checkConstraintsOfDescendentNodes.
The checkConstraintsOfNodeAndDescendents is defined with the other two in its expression tree.
It currently compiles.
I think that the first constraint check I write will mostly be a case of expression and an any call.
I had to deconstruct a lot of different data types.
In order to handle all the possible data constructors of some of the data types I deconstructed, I had to nest some case expressions.
I do not like how the spacing looks when I do that.
Therefore, I defined a bunch of helper functions for the audit.
I think I need to ensure that I covered every possible way that declaration specifiers can be in an external declaration.
What I need is to do cycle detection in the AST ADTs.
I am looking for indirect recursion on the declaration type.
I know that exists.
I only want a subset of the mutually recursive sets of ADTs in the AST.
I only want to include a cycle in the AST if the nested Declaration is an external definition.
Eh, I don't think my wording is clear.
In all fairness, I do not think the wording in the spec is precise either.
I think they have an implicit definition.
You know what, though, maybe I need to read the Semantics paragraphs of section 6.9,
I will do that next time I work on the compiler.
I am going to do this analysis on a sheet of paper.
Yes, the term external declaration is defined in the semantics in paragraph 4, sentence 2.
I still have to do analysis, though.

I am currently writing a python script to do cycle detection for me.
Right now, I am having issues with nested iterables.
I just realized why I am having issues.
I was trying to flatten the iterators using list comprehension, but that is not working.
It seems to me that python had to make a tradeoff between list comprehension reading like nested for loops or list comprehension reading like prose.
The python language designers chose to make list comprehension read like nested for loops (outer loops come first).
I am not a fan of that decision.
I found a stack overflow post about it.
The answer said something similar to what I expected.
I can complain all I want, but my cycle detection code is still not working.
I think I got it working now.
I did not.
I had a little bug that caused my code to not exhaustively search for all solutions, as I had intended it to do.
At this point, I think I just need to plug in the data.
I wish I had an easy way to do the conversion from the AST types to the python dictionary I want to transform them to, but I think it makes sense to do this task manually, at least for now.
You know what, I did a manual check (not necessarily exhaustive).
I am willing to let the details of this constraint elude me for a little longer.
This constraint might be better/easier to check for in a later phase, once I get to a point where I don't have to dig deeply through the AST to find external declarations.

Okay, my Auditable implementation for external declaration is finished.
Well, it is sort of finished.
Its implementation depends on descendent nodes' types to implement the Auditable typeclass.
I committed those changes.
Currently, the code does not compile because there is no Auditable implementation for the FunctionDefinition data type.

I need a way to indicate that some audits have not been implemented yet.
I might be able to start by providing a generic Auditable instance that throws an error of some sort.
You know what, I think it will make sense for the constraint checking methods of the Auditable typeclass to return some kind of error type wrapped in the Maybe monad.
I could even go as far as creating my own audit result type that would have 3 constructors.
The constructors would represent success, failure from an issue found by audit, and failure due to an audit not being implemented.
I like that idea.
I am not sure if that would help me go fast.
I think I will do that once I finish the minimal pipeline.
I think I will wind up looking through all of my auditing code again, either way.

I keep getting caught up in worrying about maintainability of this code.
I need to just push forward and check the constraints that pertain to the syntax that I am supporting and nothing else.
If I start partially writing code for things that I will need to fully implement anyways, I think I will be wasting my time.
You know what, audits are whatever at this point in time.
I am trying to write a minimal pipeline.
I know that the code that I am trying to translate is valid.
I can come back to audits and the like later.
What I need now are transformations.
What kinds of transformations do I need?
Well, I need to transform an AST into a symbol table.
The structure of the AST will not be gone.
It will be segmented, though.
At an abstract level, I think I want the different levels of the AST to be closer to corresponding with the scopes of identifiers.
With the program that I am trying to compile, I do not have to worry about different scopes or namespaces.
That makes this much simpler.
I also don't have to worry about declarations nested deeply in the AST like structs, enums, or init-declarator-list nodes with more than 1 elements.
I just need a symbol table that resolves types and stores the name.
I don't necessarily even need it to indicate whether or not the symbol is even initialized.
Therefore, I don't think I will.
It looks like the next thing I have to do (after flushing out my working tree) is create a simple type for a symbol table.
I will almost certainly overwrite this code in the future.
That is fine.
I think I am deeply nested in a habit of not writing anything unless I am almost positive that it is the best way of doing something.
The funny thing is that the stuff I write is often piss that needs to be rewritten.
I would like to get into the habit of throwing a little more shit at the fan.
Back on the topic of the symbol table, I think it will be fairly straightforward to convert this symbol table to assembly code.
Well, let me flush out my working tree before I start writing that code.

Okay, I created the file that will hold the data type.
The module name is Compiler.SymbolTable.SymbolTable.
I need to figure out what data each entry will hold.
Well, it might not be polymorphic.
For now, I think it can just be a list of symbol table entries.
Okay, now I have to determine the data that a symbol table entry will hold.
Well, like I said earlier, it will need to hold an identifier/symbol and its type.
I am not sure how I will handle unresolved types in the future, but that is a hump for me to get over in the future.
I am using DeclarationSpecifiers instead of TypeSpecifier.
You know what, I think that's another example of me overthinking this task.
I am going to change the code back to TypeSpecifier to make this pipeline as simple as possible.
The symbol table data type code compiles.
I guess I will check these changes in before writing code that transforms an AST to a symbol table.
Oh, I just realized the symbol table code did not compile.
I looked right past the compile errors in the AbstractSyntaxTree module.
I am glad I caught myself.
I will cover up that issue (it'll still throw a warning, thankfully) for now in order to confirm my changes are okay.

On a disconnected note, I think I want to move the Auditable instances to their own file or files.
Oh, I should mention: the changes were fine.
The symbol table code compiled fine.

All right, how am I going to convert an abstract syntax tree into a symbol table?
Well, one thing I could do is try to connect my desired output to my input.
That means that I need to have the AST of the program that I am trying to compile with my minimal pipeline.
I have computed it before.
I really wish I had a prettier way of printing it.
I wish GHC.Generics would come to my rescure.
It might.
I am going to go down that tangent for a little bit.
I got aeson kind of working for the HeaderName data type and the types it depends on.
I haven't gotten it to pretty-print out of the box yet.
I have only gotten it to serialize to a smushed JSON object that I could parse and look through in a browser console.
I guess it was better than nothing.
In order to make this solution work for a given type, I have to make it derive Generic and write a blank instance of the ToJSON typeclass.
I could do a search and replace to make all my newtypes and data types derive the Generic typeclass.
I could probably automate the creation of the type class instance boilerplate, too.
I really don't want to make that AbstractSyntaxTree module bigger.
Well, at this point in time, I don't think that should be my main concern.
I need to wrangle myself and think about my priorities.
I don't think that deriving Generic and implementing ToJSON should be the highest thing on my agenda now.
I have a better gauge of how to make pretty printing easier for arbitrary data types, and I have a better gauge of how long it could take.
