I have moved over to this file for notes.
You know what, I think I am going to check in what I have for now.
I think there are already a lot of changes.
I just found out about git difftool and vimdiff.
That shit is awesome.
I like it.
The colors are dumb for now, but the tools are cool, and I am going to use them.
I can configure the colors to be more helpful some time, anyways.

I have a couple directions that I can go in now.
I can begin writing tests.
That does not align with my idea of creating a minimal pipeline.
I will not spend time writing tests yet.
I could create a manual instance of Show for Identifier in the AST.
I would get rid of the derivation that implements Show Identifier currently.
As I was doing some basic testing on declarators and init-declarators, I think I noticed something seemed off.
I did not dig into it, and I do not remember it in detail.
My concern was the ordering of alternatives that can be parsed.
I will just leave it at that for now.
I think I will hold off manually implementing Show Identifier for now.
That sounds like a potential slow-down.
I will fix correctness issues later, especially if it is just a matter of the order of alternatives.
I am half expecting that to be an issue, and I will be able to find it pretty quickly, I think.
Okay, then what do I have to implement next.
I think the next thing I have to implement is the initializer syntax tree.
I want to look over the iso document first and get an idea of which piece of syntax I need to implement next.
I just realized that I have not specified what I am trying to implement in my minimal pipeline.
I want to be able to simply define an external variable (one outside of a procedure) as an integer and initialize its value.
You know what, maybe it would be even simpler to not even initialize that value.
I am going to try that with gcc.
It works.
My program just had the code `int x;`
It compiled perfectly fine.
It was just an object file, but that's fine for now.
I am okay with that for now.
When the code gets to the assembler, I can inspect that code because the assembler is written in python.
I just ran `stack repl Compiler/Parser/TranslationUnit.hs`
Inside of the ghci interpreter that opened up, I tinkered with the translationUnit parser.
I ran `testParse translationUnit ["int", "x", ";"]`
I believe that parsed what it should have.
However, if I added a space in the mix, it failed.
Running `testParse translationUnit ["int", " ", "x", ";"]` returned what the following.

parse error at (line 1, column 5):
unexpected "x"
expecting declaration specifiers

I am surprised.
I will look into this.
I will grep for "declaration specifiers".
I got a match.
I am digging in now using parserTrace in the Text.Parsec.Combinator module.
I think it might be my charToStringTokenParser implementation.
I wonder if it is an issue with the handling of the whitespace.
The error message seems as if the whitespace was properly skipped, though.
Well, it definitely is an issue with the way that the whitespace is skipped.
The parse works without the space, but not with the space.
Yes, it's a spacing issue.
The charToStringTokenParser implementation does not have any code for handling whitespace.
I am going to either change or parameterize that.
I think I'll just parameterize it.
Well, I could also write a wrapper for charToStringTokenParser that would parse preceding whitespace.
I don't like whitespace.
The whole lparen thing makes it so much more complicated.
It turns out that I wrote code that skips horizontal whitespace already.
It is in the stringSatisfyT definition.
I extracted the code for skipping horizontal whitespace.
In order to comply with the C standard, I might need to make the code handle newlines, not just horizontal whitespace, but I will leave it for now.
I will change the identifier definition in Preprocessor.Identifier now.
I have to change module imports and exports for that to work.
Now the whole parse works.
I get the same parse result when I have the space in the input stream to be parsed and when I don't.
The code seems to be parsing the sample string properly.
I guess I am going to move onto the next phase.
I guess that would be semantic analysis.
I will have to read the constraints and semantics of each entity that I parsed.
I might make a typeclass for constraint checks and semantic analysis.
I am looking at the first constraint.
I think that ...

I don't know what I was thinking when I began my last sentence.
I am going to read the preceding content.
I was just reading the notes.
Now, I don't remember what the difference is between the stringSatisfyT ish functions and the charToStringTokenParser function.
I am going to look at that now.
Well, charToStringTokenParser, I believe, is kind of like a cleaner version of stringParserSatisfyT.
It does not exclusively transform parsers with the type Parser String.
The stringParserSatisfyT parser transformer will transform a (Parser String) to a (String -> Bool), and if the (String -> Bool) returns True, stringParserSatisfyT transforms the parsed string to type t.
Then, stringParserSatisfyT returns the result of that transformation of the parsed string to type t.
I am going to leave a TODO comment for getting rid of stringParserSatisfyT.
I could write some nice documentation for this stuff, but I wanna get my minimal pipeline done.

I am going to continue reading my notes from two paragraphs above.
Okay, I have to write code to audit the constraints.
I almost want to run audits while parsing.
I think there are a few constraints that I already enforce in the parsers.
I just looked at the second constraint listed in section 6.9.
The constraint has a 3 next to it.
That constraint requires a symbol table.
It requires state.
I feel slightly inclined to not use state, if I don't need to.
However, I think that if I wait until parsing is finished to do constraint checks, the parsing precedence might be messed up.
Some code might parse, but then fail constraint checks later in the pipeline.
This could conceivably happen when the parsed code could have been parsed in another way.
I am not certain that I will be able to stomp out this possibility by simply ordering/reordering the alternatives (parsers combined with the <|> operator).
That said, I think it will be easiest for now if I have constraint audits in a separate stage of the pipeline.
You know what, though, I could parameterize the method that performs constraint checks with a boolean that would determine whether or not to perform recursive constraint checks on the descendent nodes.
I have not written out my idea for the use of typeclasses here yet.
I think it could be good to use a typeclass that would have a method that checks all of the constraints for a given node in the AST.
I could name that method checkConstraints or something like that.
I think it would return a Bool.
It could also return a Maybe type.
I think it would be a Bool because I only need two values, pass or fail.
I could probably find some nice way to sugar it up, but for now I think having True represent pass and False represent fail is fine.
I guess I will implement the typeclass in the AbstractSyntaxTree module for now.
I am naming the type class Auditable for now.
I did it.
I think I did it correctly.
I believe this is the first typeclass I have ever defined.
I have implemented them before, but I think this is the first one I have defined.
It compiiled!
Okay, now I am going to try to implement this typeclass inside the AbstractSyntaxTree module.
You know what, I think there is going to be a lot of stuff in the next commit.
I want to just commit my progress.
This paragraph is not included in the commit I just made.
Anyways, I am moving on with a much cleaner working tree.
I just made some more abstractions to the Auditable typeclass.
There are now three methods: checkConstraints, checkConstraintsOfNode, and checkConstraintsOfDescendentNodes.
The checkConstraints method is defined using the others.
I changed the typeclass again.
It has three methods: checkConstraintsOfNodeAndDescendents, checkConstraintsOfNode, and checkConstraintsOfDescendentNodes.
The checkConstraintsOfNodeAndDescendents is defined with the other two in its expression tree.
It currently compiles.
I think that the first constraint check I write will mostly be a case of expression and an any call.
I had to deconstruct a lot of different data types.
In order to handle all the possible data constructors of some of the data types I deconstructed, I had to nest some case expressions.
I do not like how the spacing looks when I do that.
Therefore, I defined a bunch of helper functions for the audit.
I think I need to ensure that I covered every possible way that declaration specifiers can be in an external declaration.
What I need is to do cycle detection in the AST ADTs.
I am looking for indirect recursion on the declaration type.
I know that exists.
I only want a subset of the mutually recursive sets of ADTs in the AST.
I only want to include a cycle in the AST if the nested Declaration is an external definition.
Eh, I don't think my wording is clear.
In all fairness, I do not think the wording in the spec is precise either.
I think they have an implicit definition.
You know what, though, maybe I need to read the Semantics paragraphs of section 6.9,
I will do that next time I work on the compiler.
I am going to do this analysis on a sheet of paper.
Yes, the term external declaration is defined in the semantics in paragraph 4, sentence 2.
I still have to do analysis, though.

I am currently writing a python script to do cycle detection for me.
Right now, I am having issues with nested iterables.
I just realized why I am having issues.
I was trying to flatten the iterators using list comprehension, but that is not working.
It seems to me that python had to make a tradeoff between list comprehension reading like nested for loops or list comprehension reading like prose.
The python language designers chose to make list comprehension read like nested for loops (outer loops come first).
I am not a fan of that decision.
I found a stack overflow post about it.
The answer said something similar to what I expected.
I can complain all I want, but my cycle detection code is still not working.
I think I got it working now.
I did not.
I had a little bug that caused my code to not exhaustively search for all solutions, as I had intended it to do.
At this point, I think I just need to plug in the data.
I wish I had an easy way to do the conversion from the AST types to the python dictionary I want to transform them to, but I think it makes sense to do this task manually, at least for now.
You know what, I did a manual check (not necessarily exhaustive).
I am willing to let the details of this constraint elude me for a little longer.
This constraint might be better/easier to check for in a later phase, once I get to a point where I don't have to dig deeply through the AST to find external declarations.

Okay, my Auditable implementation for external declaration is finished.
Well, it is sort of finished.
Its implementation depends on descendent nodes' types to implement the Auditable typeclass.
I committed those changes.
Currently, the code does not compile because there is no Auditable implementation for the FunctionDefinition data type.

I need a way to indicate that some audits have not been implemented yet.
I might be able to start by providing a generic Auditable instance that throws an error of some sort.
You know what, I think it will make sense for the constraint checking methods of the Auditable typeclass to return some kind of error type wrapped in the Maybe monad.
I could even go as far as creating my own audit result type that would have 3 constructors.
The constructors would represent success, failure from an issue found by audit, and failure due to an audit not being implemented.
I like that idea.
I am not sure if that would help me go fast.
I think I will do that once I finish the minimal pipeline.
I think I will wind up looking through all of my auditing code again, either way.

I keep getting caught up in worrying about maintainability of this code.
I need to just push forward and check the constraints that pertain to the syntax that I am supporting and nothing else.
If I start partially writing code for things that I will need to fully implement anyways, I think I will be wasting my time.
You know what, audits are whatever at this point in time.
I am trying to write a minimal pipeline.
I know that the code that I am trying to translate is valid.
I can come back to audits and the like later.
What I need now are transformations.
What kinds of transformations do I need?
Well, I need to transform an AST into a symbol table.
The structure of the AST will not be gone.
It will be segmented, though.
At an abstract level, I think I want the different levels of the AST to be closer to corresponding with the scopes of identifiers.
With the program that I am trying to compile, I do not have to worry about different scopes or namespaces.
That makes this much simpler.
I also don't have to worry about declarations nested deeply in the AST like structs, enums, or init-declarator-list nodes with more than 1 elements.
I just need a symbol table that resolves types and stores the name.
I don't necessarily even need it to indicate whether or not the symbol is even initialized.
Therefore, I don't think I will.
It looks like the next thing I have to do (after flushing out my working tree) is create a simple type for a symbol table.
I will almost certainly overwrite this code in the future.
That is fine.
I think I am deeply nested in a habit of not writing anything unless I am almost positive that it is the best way of doing something.
The funny thing is that the stuff I write is often piss that needs to be rewritten.
I would like to get into the habit of throwing a little more shit at the fan.
Back on the topic of the symbol table, I think it will be fairly straightforward to convert this symbol table to assembly code.
Well, let me flush out my working tree before I start writing that code.

Okay, I created the file that will hold the data type.
The module name is Compiler.SymbolTable.SymbolTable.
I need to figure out what data each entry will hold.
Well, it might not be polymorphic.
For now, I think it can just be a list of symbol table entries.
Okay, now I have to determine the data that a symbol table entry will hold.
Well, like I said earlier, it will need to hold an identifier/symbol and its type.
I am not sure how I will handle unresolved types in the future, but that is a hump for me to get over in the future.
I am using DeclarationSpecifiers instead of TypeSpecifier.
You know what, I think that's another example of me overthinking this task.
I am going to change the code back to TypeSpecifier to make this pipeline as simple as possible.
The symbol table data type code compiles.
I guess I will check these changes in before writing code that transforms an AST to a symbol table.
Oh, I just realized the symbol table code did not compile.
I looked right past the compile errors in the AbstractSyntaxTree module.
I am glad I caught myself.
I will cover up that issue (it'll still throw a warning, thankfully) for now in order to confirm my changes are okay.

On a disconnected note, I think I want to move the Auditable instances to their own file or files.
Oh, I should mention: the changes were fine.
The symbol table code compiled fine.

All right, how am I going to convert an abstract syntax tree into a symbol table?
Well, one thing I could do is try to connect my desired output to my input.
That means that I need to have the AST of the program that I am trying to compile with my minimal pipeline.
I have computed it before.
I really wish I had a prettier way of printing it.
I wish GHC.Generics would come to my rescure.
It might.
I am going to go down that tangent for a little bit.
I got aeson kind of working for the HeaderName data type and the types it depends on.
I haven't gotten it to pretty-print out of the box yet.
I have only gotten it to serialize to a smushed JSON object that I could parse and look through in a browser console.
I guess it was better than nothing.
In order to make this solution work for a given type, I have to make it derive Generic and write a blank instance of the ToJSON typeclass.
I could do a search and replace to make all my newtypes and data types derive the Generic typeclass.
I could probably automate the creation of the type class instance boilerplate, too.
I really don't want to make that AbstractSyntaxTree module bigger.
Well, at this point in time, I don't think that should be my main concern.
I need to wrangle myself and think about my priorities.
I don't think that deriving Generic and implementing ToJSON should be the highest thing on my agenda now.
I have a better gauge of how to make pretty printing easier for arbitrary data types, and I have a better gauge of how long it could take.

Okay, I have a better gauge of how I could use aeson and generics to implement pretty printing.
I would like to learn more about generics in Haskell because I think they seem to be able to solve a lot of problems for which I instinctively look to macro systems or runtime reflection.
Anyways, that is a trap, something that could take me off of my current course.
I am working on writing a full pipeline right now.
That is my focus, not generics.
Okay, how am I going to convert the parsed AST to a symbol table?
Well, I think I have some recent notes that I am going to review before writing more.
Okay, I am going to try to start with my desired output and my parsed AST and connect the two.
I can create intermediate representations, if needed.
I am conceptualizing this problem like so.
I am on a platform in a tree, like a platform at some zipline/ropes course.
The AST of the program that I am supporting is represented by the platform.
I have a platform in the distance that I want to reach.
That platform in the distance represents the assembly code that I would like to generate.
Note that I have not written this assembly code yet.
Perhaps I should.
I will think on that after I have finished painting my mental image.
I can always climb down and walk to the base of the tree that holds the platform I want to reach.
From the ground, I can climb up to the platform that I want to reach, which I will now call the target platform.
The process of climbing down from my starting platform, walking to base of the tree holding the target platform, and climbing up to the target platform, represents manually compiling a C program.
Manual compilation is fine and dandy, but I like ziplines.
Ziplines are cool.
Anyways, I need to get a rope or series of ropes from my starting platform to the destination platform.
I can build intermediate platforms between the starting platform and destination platform, if needed.
Those intermediate platforms represent any intermediate representations that I use, like a symbol table with definitions/declarations.
All right, I'm not sure if that analogy is helpful for me beyond making me feel a little more free to use more intermediate representations.
Well, that's something and not nothing.
Okay, my symbol table is currently a wrapper around a list of symbol table entries.
How am I going to get those symbol table entries?
I think I should be able to get them by extracting the list of external declarations from the translation unit.
I can map the list of external declarations to a list of symbol table entries.
In the future, I may need to do some flattening, as there might be several symbol table entries to be made from a single external declaration, but that is a future hump to get over.
I like my current conceptualization.
I feel a sense of direction and a sense that I can do this, much more pleasant than some of the discouraging thoughts and attitudes I have had at times in the past few weeks.
Okay, I do not know where I will write the code that converts an AST to a symbol table.
Well, it will be in the "Compiler" directory, possibly nested, but definitely in that directory somewhere.
I already have a subdirectory named "Parser" or "Parsers".
I will probably add another directory with a name pertaining to this process.
I am not sure what I would even call this process.
Well, I guess this is semantic analysis.
It might be intertwined with syntactical analysis in the future, but it is not intertwined yet (hasn't even been written).
I guess I will name the directory "SemanticAnalysis".
That sounds good to me.
Following semantic analysis will probably be audits (if I don't include those in this stage of the pipeline) and then code generation.
Oh, I just remembered that I have not written the RISC-V assembly code that I want the compiler to generate.
It should be really simple.
I won't need a code section because I will only have a data declaration.
I will need a bss section that declares an int with label x.
I think that is all I need.
I might need to also declare the label x to be global.
I don't think my assembler has any special support for global declarations (it treats all symbols the same).
I think the code will be less than 10 lines.
I just read the comment near the top of my assembler.py file.
The comment said that the assembler does not support sections/segments thus far, nor data.
I have been messing around with the assembler a little bit.
I think I am going to refactor some of it.
Wait, no, I am creating a minimal pipeline.
I will get there when I get there.
I can change things if I want.
I can get by with just writing the target program and adding support for the required assembly constructs later.
Here is all that I think I want to generate:

    .section bss
x:  .int

That is all for now.
I have not seen an int assembler directive before.
I might change this target in the future, but for now, this is it.
I might change spacing.
There are a lot of things that I might change, but I think the pseudo-assembly that I wrote gets the idea of my target across concretely.
I want an uninitialized integer in the bss section, and I want that integer to have the label x.
That is all I care about at this time.
All other directives can come later and spacing changes can come later.
I honestly did not know the term assembly directive until I read it 20 minutes ago.
I am glad that I have a term to describe those now.
That will help me search for more information online.
It seems like there is no standard set of assembly directives for RISC-V.
I have found some pages that present numerous directives as if they were dogmatic, but I do not think they are.
I do not know if it would even be possible to make a dogmatic set of assembly directives, as there are many different formats of object files that assembly files are assembled into, depending on
    platform and such.
My assembler is assembling assembly files to ELF objects, but there are numerous alternatives that I could have used, especially because I will be building the linker and loader, too.
My assembler is in a really bad spot.
I am probably going to rewrite a lot of it.
I also overdid some things like support for extensions to the RISC-V 32 bit integer base instruction set.
I only determined that I would not support all of those extensions after I began writing the SystemVerilog for the CPU, though, so that was a totally understandable mistake.
Okay, I think I already determined the name of the directory that will hold the code for transforming an AST to a symbol table.
I decided earlier that I would name the directory SemanticAnalysis.
I think I will move the Compiler.SymbolTable.SymbolTable to another directory (and change the module name) in the future.
For now, I am going to leave it as is.
I am creating a single module in the SemanticAnalysis directory: SemanticAnalysis.hs.
It's very creative, I know.
I have some bare bones for the conversion defined.
I am extracting the external declarations from the translation unit.
From there, I am using map to convert each of the external declarations to a symbol table entry.
From here, I have to implement the logic that converts an external declaration into a symbol table entry.
I am writing that logic in the convertExternalDeclarationToSymbolTableEntry function.
I realized that I cannot simply map each and every external declaration or function definition to a symbol table entry.
Some will be invalid.
There will probably be cases where I will need to throw an error.
There will be cases where I will need to throw an error.
I do not want to simply throw an error by calling the impure error function.
I think I would rather use the Either monad.
I have to make a choice to do some kind of error handling right here and now because I am not supporting function definitions.
Well, I will just use the error function for now.
I will remove that later.
Okay, now I have narrowed down the logic for me to write to converting a declaration to a symbol table entry.
The type (at least in this case) should be easy to determine.
It will simply be the type specifiers.
Well, you know what, any pointers "modifiers" in the declarator also makes a difference.
Also, type qualifiers might be important.
I don't think storage class specifiers will matter for type resolution.
Well, they actually might impact constraints/semantics with type inference, but that is much farther down the road from where I am at now.
I can extract all of the type specifiers from a declaration.
If there are none, I can throw an error.
Okay, this has gotten really messy and error prone for future me.
I am going to keep marching forward, though.
Silly me for making the second field of a symbol table entry a single type specifier.
I guess that works for now, though.
I am going to use filter and head.
I am disappointed that using the head function, an unsafe function, does not cause GHC to give a warning.
I know not to use head, and I can search for it some other time.
I have some messy code with some long ass lines and long function names and annoyingly verbose deconstructions.
I am using head again in my definition of a function extractSymbolNameFromInitDeclaratorList.
Okay, well, I made a lot of headway in this session.
I will come continue tomorrow.
You know what, as nasty as a lot of the code is that I am writing is, I think most of the gross things about it would be fixed by simply using the Maybe, List, and Either monads.
I have pulled a hoosier move.
It's very practical at this point in time, though.
I have written some basic debugging tests in Main.
The debugging tests are really just a few definitions, but they will help me debug much faster.
I am at a point where my code is compiling and I expect it to translate an AST to a symbol table (as I have defined it so far).
In the above statement, by "an AST", I mean the AST generated from the source code that I am focusing on compiling for the minimal full pipeline.
I have code that builds the aformentioned AST in the Main module.
It is unsafe, but that's okay because I am only using that code to debug.
I am going to try to build on top of the code that builds the AST.
I have tested that the AST is parsed successfully.
I am going to try to convert that AST to a symbol table.
I think I'll just need one more symbol and one function call.
I did that; I defined symbolTable in Main.
The code compiled.
I tried to evaluate symbolTable in ghci, but it threw an exception, saying that there is no instance of Show for SymbolTable, which I believe is true.
I do not think I had SymbolTable or SymbolTableEntry derive anything.
I just made all the data types in Compiler.SymbolTable.SymbolTable derive Show.
The code compiles, and I was able to evaluate symbolTable and see it's value in ghci.
It seemed correct.
It had one entry, x, and that entry had the symbol name "x" (nested in a bunch of types) and the type specifier Int_, the type specifier constructor which represents an int.
Okay, I am happy with the progress I have made.
I am going to commit the changes.
