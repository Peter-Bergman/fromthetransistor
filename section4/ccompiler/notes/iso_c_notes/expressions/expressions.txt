	----------------------------- Expressions -----------------------------------

An expression is a sequence of operators and operands that specifies computation of a value, or that designates an object or a function, or that generates side effects, or that performs a combination thereof.
The value computations of the operands of an operator are sequenced before the value computation of the result of the operator.

If a side effect on a scalar object is unsequenced relative to either a different side effect on the same scalar object or a value computation using the value of the same scalar object, the behavior is undefined.
If there are multiple allowable orderings of the subexpressions of an expression, the behavior is undefined if such an unsequenced side effect occurs in any of the orderings.

The grouping of operators and operands is indicated by the syntax. 
Except as specified later, side effects and value computations of subexpressions are unsequenced.

Some operators (the unary operator ~, and the binary operators <<, >>, &, ^, and |, collectively described as bitwise operators) are required to have operands that have integer type.
These operators yield values that depend on the internal representations of integers, and have implementation-defined and undefined aspects for signed types.

If an exceptional condition occurs during the evaluation of an expression (that is, if the result is not mathematically defined or not in the range of representable values for its type), the behavior is undefined.

The effective type of an object for an access to its stored value is the declared type of the object, if any.
If a value is stored into an object having no declared type through an lvalue having a type that is not a character type, then the type of the lvalue becomes the effective type of the object for that access and for subsequenct accesses that do not modify the stored value.
If a value is copied into an object having no declared type using memcpy or memmove, or is copied as an array of character type, then the effective type of the modified object for that access and for subsequent accesses that do not modify the value is the effective type of the object from which the value is copied, if it has one.
For all other accesses to an object having no declared type, the effective type of the object is simply the type of the lvalue used for the access.

An object shall have its stored value accessed only by an lvalue expression that has one of the following types.
	- a type compatible with the effective type of the object
	- a qualified version of a type compatible with the effective type of the object
	- a type that is the signed or unsigned type corresponding to the effective type of the object
	- a type that is the signed or unsigned type corresponding to a qualified version of the effective type of the object
	- an aggregate or union type that includes one of the aforementioned types among its members (including, recursively, a member of a subaggregate or contained union)
	- a character type

A floating expression may be contracted, that is, evaluated as though it were a single operation, thereby omitting rounding errors implied by the source code and the expression evaluation method.
The FP_CONTRACT pragma in <math.h> provides a way to disallow contracted expressions.
Otherwise, whether and how expressions are contracted is implementation-defined.


