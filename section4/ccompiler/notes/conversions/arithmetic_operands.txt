----------------------------- Boolean, characters, and integers ----------------------------------------
Every integer type has an integer conversion rank as follows:
	- No two integer types shall have the same rank, even if they have the same representation
	- The rank of a signed ineger type shall be greater than the rank of any signed integer with less precision.
	- The rank of long long int shall be greater than the rank of long int, which shall be greater than the rank of int, which shall be greater than the rank of short int which shall be greater than the rank of signed char.
	- The rank fo any unsigned type shall equal the rank of the corresponding signed integer type, if any.
	- The rank of any standard integer type shall be greater than the rank of any extended integer type with the same width.
	- The rank of char shall equal the rank of signed char and unsigned char.
	- The rank of _Bool shall be less than the rank of all other standard integer types.
	- The rank of any enumerated type shall equal the rank of the compatible integer type.
	- The rank of any extended signed integer type relative to another extended signed integer type with the same precision is implementation-defined, butt still subject to the other rules for determining the integer conversion rank.
	- For all integer types T1, T2, and T3, if T1 has greater rank than T2 and T2 has greater rank than T3, then T1 has greater rank than T3.

The following may be used in an expression wherever an int or unsigned int may be used:
	- An object or expression with an integer type (other than int or unsigned int) whose integer conversion rank is less than or equal to the rank of int and unsigned int
	- A bit-field of type _Bool, int, signed int, or unsigned int.

If an int can represent all values of the original type (as restricted by the width, for a bit-field), the value is converted to an int; otherwise, it is converted to an unsigned int.
These are called integer promotions.
All other types are unchanged by integer promotions.

The integer promotions preserve value including sign.
As discussed earlier, whether a "plain" char is treated as signed is implementation-defined.


---------------------------------- Boolean type -----------------------------------------------------------

When any scalar value is converted to _Bool, the result is 0 if the value compares equal to 0;
Otherwise, the result is 1.

------------------------------------- Signed and unsigned integers ------------------------------------------

When a value with integer type is converted to another integer type other than _Bool, if the value can be represented by the new type, it is unchanged.

Otherwise, if the new type is unsigned, the value is converted by repeatedly adding or subtracting one more than the maximum value that can be represented in the new type until the value is in the range of the new type.
-- This is interesting. I want to test this out.

Otherwise, the new type is signed and the value cannot be represented in it;
either the result is implementation defined or an implementation-defined signal is raised.

---------------------------------------- Real floating and integer --------------------------------------------

When a finite value of real floating type is converted to an integer the type other than _Bool, the fractional part is discarded (i.e., the value is truncated toward zero).
If the value of the integral part cannot be represented by the integer type, the behavior is undefined.

When a value of integer type is converted to a real floating type, if the value being converted can be represented exactly in the new type, it is unchanged.
If the value being converted is in the range of values that can be represented but cannot be represented exactly, the result is either the nearest higher or nearest lower representable value, chosen in an implementation-defined manner.
If the value being converted is outside the range of values that can be represented, the behavior is undefined. 
Results of some implicit conversions may be represented in greater precision and range than that required by the new type.


------------------------------------------ Complex Types ----------------------------------------------------

When a complex type is convered to another complex type, both the real and imaginary parts follow the conversion rules for the real types.


------------------------------------------- Real and complex ---------------------------------------------------

When a value of real type is converted to a complex type, the real part of the complex resultt value is determined by the rules of conversion to the corresponding real type and the imaginary part of tthe complex resultt value is a positive zero or an unsigned zero.

When a value of complex type is converted o a real type, the imaginary par of the complex value is discarded and the value of the real part is convered according to the conversion rules for the corresponding real type.


------------------------------------------ Usual arithmetic conversions ---------------------------------------

Many operators that expect operands of arithmetic type cause conversions and yield result types in a similar way.
The purpose is to determine a common real type for the operands and result.
For the specified operands, each operand is converted, without change of type domain, to a type whose corresponding real type is the common real type.
Unless explicityly stated otherwise, the common real type is also the corresponding real type of the result, whose type domain is the type domain of the operands if they are the same, and complex otherwise.

This pattern is called usual arithmetic conversions:
	- First, if the corresponding real type of either operand is long double, the other operand is converted, without change of type domain, to a type whose corresponding real type is long double.
	- Otherwise, if the corresponding real type of either operand is double, the other operand is converted, without change of type domain, to a type whose corresponding real type is double.
	- Otherwise, if the corresponding real type of either operand is float, the other operand is converted, without change of type domain, to a type whose corresponding real type is float.
	- Otherwise, the integer promotions are performed on both operands. Then the following rules are applied to the promoted operands:
		- If both operands have the same type, then no further conversion is needed.
		- Otherwise, if both operands have signed integer types or both have unsigned integer types, the operand with the type of lesser integer conversion rank is converted to the type of the operand with greater rank.
		- Otherwise, if the operand that has unsigned integer type has rank greater or equal to the rank of the type of the other operand, then the operand with signed integer type is converted to the type of the operand with unsigned integer type.
		- Otherwise, if the type of the operand with signed integer type can represent all of the values of the type of the operand with unsigned integer type, then the operand with unsigned integer type is converted to the type of the operand with signed integer type.
		- Otherwise, both operands are converted to the unsigned integer type corresponding to the type of the operand with signed integer type.

The values of floating operands and of the results of floating expressions may be represented in greater precision and range than that required by the type; the types are not changed thereby.






